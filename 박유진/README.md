### 목차
1. [250304_화](#250304_화)
2. [250305_수](#250305_수)
3. [250306_목](#250306_목)

---
<details>
  <summary><h1>250304_화</h1></summary>

## 1. PM특강_프로젝트 갈등관리 전략
1. 문제해결/혐력
2. 강압/경쟁
3. 회피/지연
4. 수용/수습
5. 타협/절충


> [문제해결/협력]
    - 가장 좋은 전략_ 갈등을 뿌리뽑고 협력상태로 가게 되는 것
    - 중요한 의사 결정(도전해야 할 과제)
> [강압/경쟁]
    - 부정적인 효과가 오래 지속되는 전략 (모두 만들고 가장 좋은거로 가자!)
    - 긴급한 경우
> [회피/지연]
    - 사소한 갈등_감정적으로 격양될 때
    - 분리시키고 지연시키기
> [수용/수습]
    - 내 잘못이 명백한 경우
    - 어떻게든 책임질 것
> [타협/조화]
    - 가장 마지막에 적용을 검토할 것.
    - 갈등해결 노력 최소화(무난한 결론)

## 2. 프론트 공부
1. 패키지 메니저 (npm, yarn, pnpm)
- npm : 가장 기본이 되는 것 / 번용성 좋음 / 속도 느림 / 패키지 개별 저장해서 디스크 사용량 큼
- yarn : 패키지 설치 속도 향상됨 / 캐시 써서 중간정도 속도 / 디스크 사용량도 중간정도
- pnpm : 설치 속도 빠름 / 디스크 사용량 적음 / 모노레포에 좋음

-> pnpm을 우선적으로 사용해볼 예정.

2. node.js vs next.js
```
<Node.js>
- JS를 브라우저 밖에서도 실행할 수 있도록함.
- 실행 환경임임
<Next.js>
- Node.js 환경에서 실행되는 리엑트 기반 프레임워크
- 리엑트에 SSR, SSG 기능 추가한 웹 프레임워크
```

3. clsx, tailwind-merge, class-variance-authority
-> CSS 클래스들을 동적으로 조합하는 데 도움을 줌

```
<clsx (Classnames + JSX)>
- 여러 CSS 클래스를 조건부로 동적으로 조합하는 유틸리티
- 불필요한 클래스를 자동으로 필터링함
- classnames보다 성능 빠름
- 테일윈드말고 다른 일반 CSS에도 사용 가능
- 클래스 충돌 방지기능 없음
- 테일윈드 최적화된건 아님

<tailwind-merge>
- clsx랑 비슷하지만, 테일윈드 전용임.
- 중복되는 클래스가 있으면 최신 스타일이 우선 적용됨
- 클래스 충돌 방지된
- clsx랑 같이 사용 가능
- 그런데 테일윈드  css에만 사용가능
- 조건부 클래스 적용이 불편해서 clsx랑 써야 더 편하게 됨

<class-variance-authority (CVA)>
- 컴포넌트의 기본 스타일 정의 가능함
- variants 관리 편리함
- clsx, tailwind-merge랑 사용하는 것도 가능
- 대신 간단한 클래스 조합에는 오버스팩, 학습 필요
```

</details>

<details>
  <summary><h1>250305_수</h1></summary>
---
## 1. 와이어프레임 작성 및 회의
![피그마](./img/250305_figma.png)

## 2. 제출 문서 작성 및 환경 세팅
- 노션, 깃랩, 지라 정리
- 특화PJT 1차 전문가 리뷰 사전 자료 작성

## 3. 리엑트+AI 특강 수강
< 리엑트 특징 >
-> 단방향
-> 구조 생성하는 역할 (markup generation)
-> 시간의 흐름에 따라 변화가 발생하면 이를 감지해서 리렌더링
    - 이를 감지하기 위해서는 선언이 필요함.

- 관심사의 분리, jsx

</details>

<details>
  <summary><h1>250365_목</h1></summary>

## 1. 프론트 환경 공부 (런타임, 프레임워크, 빌드, 패키지 등)

---

### 1-1. JS 실행 환경 ?

> JS 코드를 실행할 수 있는 환경 (= JS 코드를 해석하고 실행할 수 있는 런타임)
> 

<aside>

[JS 실행 환경 기본 요소]

1. JS 엔진 (코드 → 기계어) 
: V8 엔진(구글크롬, node.js) / SpiderMonkey(모질라 파이어폭스) / JSCore(사파리)
2. 호스트 환경 (js엔진이 실행되는 환경 → API를 제공해서 다양한 작업 수행함)
: 웹 브라우저 / node.js(서버, CLI) / Deno, Bun(다른 js 런타임)
</aside>

- **대표적인 JavaScript 실행 환경**

| 실행 환경 | 주요 JS 엔진 | 특징 |
| --- | --- | --- |
| **브라우저 (Chrome, Firefox, Safari, Edge 등)** | V8, SpiderMonkey, JavaScriptCore | DOM 조작, 웹 API 지원 |
| **Node.js** | V8 | 서버 개발, 파일 시스템, 네트워크 API 지원 |
| **Deno** | V8 | 보안 강화, 최신 JS/TS 지원 |
| **Bun** | JavaScriptCore | 빠른 실행 속도, 빌트인 패키지 매니저 |

### 1-2. Node.js

> JS 코드가 브라우저 밖에서도 실행될 수 있도록 만든 런타임 환경임
→ “Node.js를 설치한다” = “내 컴퓨터에서 브라우저 없어도 js 실행할 수 있는 환경을 깐다!”
- 기본적으로 npm(node package manager)를 포함함
> 
- 이게 필요한 이유
    - 정적 웹사이트 (사이트 소개 등)에서 js는 웹 서버 없이도 동작할 수 있음
    - 동적 웹사이트 (DB 정보 가져올때, 백엔드랑 통신할 때 _ 게시판, 로그인, 채팅 등)에서는 웹 서버 필요

→ js를 위한 실행 환경 _ node.js

→ java를 위한 실행 환경 _ jvm ( spring boot 프레임워크가 이 작업 편리하게 해줌)

`<node.js로 프&백 vs 프:node.js 백:spring boot>`

- node.js로 프론트, 백엔드 개발 모두 가능하다. (백 _ express.js , nestjs 사용)
- spring boot로도 둘 다 개발 가능하다 (프론트 _ jsp사용)

→ 그런데 왜 프론트랑 백엔드 다르게 개발할까?

|  | Node.js(프론트) + Node.js(백엔드, Express.js) | Node.js(프론트) + Spring Boot(백엔드) |
| --- | --- | --- |
| **장점** | - 단일 언어 사용 → 개발 생산성 good  <br>- 빠른 개발 속도 (비동기 기반, npm 활용)  <br>- 경량 서버 (Express.js는 가벼운 웹 프레임워크)  <br>- 서버리스와 궁합이 좋음 | - 대규모에 적합 (멀티스레드 기반)  <br>- 트랜잭션 관리 우수 (JPA, Hibernate)  <br>- 유지보수성 높음  <br>- 보안성 우수 |
| **단점** | - 싱글 스레드 환경 → CPU 집중 작업에 불리  <br>- 트랜잭션 관리, 보안, 멀티스레드 성능에서 Spring Boot가 더 우수  <br>- 대규모 유지보수 어려움 (빠른 생태계 변화, npm 패키지 의존성) | - Node.js로 프론트/백 통합 개발하는 것보다 복잡  <br>- JVM 실행으로 인해 서버 비용이 상대적으로 높을 수 있음 |

→ 우리 서비스는 대규모 서비스, 금융, 트랜잭션, 보안이 중요하므로 후자 선택

### 1-3. React & Next.js

- React (라이브러리)
    - UI를 구축하는 js 라이브러리
    - 컴포넌트 기반 구조로 재사용성이 좋음
    - 단순한 CSR을 기본으로 하는데 Next.js랑 쓰면 SSR도 가능
- Next.js (리엑트 프레임워크)
    - react의 기능을 확장해서 SSR, SSG, API routes 등을 제공하는 프레임워크
    - SEO 최적화 가능
    - 기본적으로 Webpack를 써서 빌드함.

### 1-4. 패키지 매니저 & 빌드 도구

< 패키지 매니저 >

> -  외부 라이브러리(리엑트 등)을 설치 및 관리
- 프로젝트 의존성 효율적으로 관리
- 패키지 버전 충돌 방지, 캐싱 등으로 속도 최적화
> 
- npm, pnpm, yarn
    - npm : nodejs 기본 패키지 매니저
    - yarn : 병렬 설치해서 속도 빠름
    - pnpm : 중복 패키지 최소화하고 디스크 절약

<빌드 도구>

- 빌드 : 번들링(여러 js, css, 이미지 파일을 하나로 묶어주는 도구), 코드 최적화, 테스트 자동 실행 등등 수행
    - 빌드 : 전체 프로젝트를 빌드하고 배포하는거
    - 번들러 : 파일을 묶어주는 것
- webpack, vite, parcel, Esbuild (빌드도구 + 번들러 역할)
- CRA : 빌드 도구 (내부적으로 webpack으로 번들링 수행함)

### 1-5. Next.js & CRA

> - react는 단순 ui 라이브러리여서 실제 프로젝트에서 실행하려면 개발 환경이 필요하다.
- next.js랑 cra는 리엑트를 쓸 때 필요한 개발 환경을 자동으로 설정해준다는 공통점이 있는데, 방식이 다르다.
> 

<리엑트 프로젝트 실행할 때 필요한 기본 개발 환경>

- 리엑트 라이브러리
- js/ts
- jsx지원
- 모듈 시스템
- 개발 서버
- 번들러
- 패키지 매니저
- 빌드 도구

<CRA>

- 내부적으로 Webpack이랑 babel을 사용해서 개발 환경을 구성함
- CSR(클라이언트 사이드 렌더링)만 지원

<Next.js>

- Webpack + Turbopack 지원
- CSR, SSR, SSG  다 가능

→ Next.js를 사용할 경우 추가적인 번들러나 불필요한 개발 도구는 제외할 수 있음

### 1-6. 리엑트 환경할 때 필요한 것

**React**→ UI 라이브러리

**Next.js**→ 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG) 등 제공하는 React 프레임워크

**pnpm**→ 빠르고 효율적인 패키지 매니저 (npm, yarn보다 성능이 우수)

**Node.js**→ 실행 환경 (Next.js는 Node.js 기반)

**TypeScript** → 더 안전한 코드 작성 가능

**ESLint + Prettier**→ 코드 품질 및 스타일 관리

- 참고 (vite vs webpack)
    
    Vite는 기본적으로 CSR 중심이다.
    
    그래서 next.js 쓸거면 기본으로 설정되어있는 webpack 사용하는게 더 호환성이 좋다.
    
    Webpack은 Next.js의 SSR(서버 사이드 렌더링) 및 SSG(정적 사이트 생성) 기능과 최적화되어 있음.
    
    ✔ Next.js는 Webpack을 기반으로 코드 스플리팅, 이미지 최적화 등을 자동 지원함.
    
    ✔ Webpack은 Next.js의 API Routes, 환경 변수 시스템 등과 호환성이 높음.
    
    - webpack vs vite
        - webpack : 모든 js파일을 하나의 번들로 묶고 나서 실행함, 좀 느림
        - vite
            - 브라우저의 ESM(ECMAScript Modules) 기능을 활용하여 개발 서버에서 즉시 실행
            - 전체 번들링을 하는게 x → 필요한 파일만 로드함
            - 개발중에는 esbuild를 써서 변환하고, 프로덕션 빌드는 Rollup을 사용함
            - 개발환경 vs 프로덕션 빌드
                
                
                | 비교 항목 | 개발 환경 (Development) | 프로덕션 빌드 (Production) |
                | --- | --- | --- |
                | **목적** | 빠른 개발 & 코드 수정 | 최적화된 코드 배포 |
                | **파일 번들링** | 최소화 X (빠른 실행이 목적) | 코드 압축 & 최적화 |
                | **소스 맵 (Source Map)** | 포함 (디버깅용) | 제거 (보안 & 성능) |
                | **HMR (핫 모듈 리로드)** | 지원 (빠른 코드 변경 반영) | 비활성화 |
                | **코드 압축 (Minify)** | 없음 | UglifyJS, Terser 등으로 압축 |
                | **트리 셰이킹 (Dead Code 제거)** | 비활성화 | 불필요한 코드 제거 |
                | **배포 가능 여부** | 개발 중이라 배포 X | 최적화된 상태로 배포 |
                
                **즉, 개발 환경에서는 속도(빠른 코드 변경)가 중요하고, 프로덕션에서는 최적화(성능 & 용량 감소)가 중요**
                
                ## **Vite에서 개발 환경과 프로덕션 빌드의 차이**
                
                Vite는 **개발 환경과 프로덕션 빌드 환경에서 서로 다른 빌드 도구를 사용**해.
                
                | 환경 | 사용하는 빌드 방식 | 설명 |
                | --- | --- | --- |
                | **개발 환경 (dev mode)** | **esbuild** | 초고속 트랜스파일링, ESM 기반 개발 서버 |
                | **프로덕션 빌드 (build mode)** | **Rollup** | 코드 최적화, 번들링, 트리 셰이킹 |
                
                **Vite가 esbuild를 사용하는 이유** → 개발 속도가 빠르기 때문!
                
                 **Vite가 Rollup을 사용하는 이유** → 최적화된 번들 파일을 생성하기 때문!
                
                ---
                
                ## **Webpack에서 개발 환경과 프로덕션 빌드의 차이**
                
                Webpack은 **개발 환경과 프로덕션 빌드 환경에서 설정이 다름**.
                
                | 환경 | 사용하는 빌드 방식 | 설명 |
                | --- | --- | --- |
                | **개발 환경 (dev mode)** | Webpack Dev Server | 빠른 개발 속도 & HMR 지원 |
                | **프로덕션 빌드 (build mode)** | Webpack 최적화 | 코드 압축, 트리 셰이킹, 번들링 |

---

## 2. 의존성, 환경변수

---

- env에는 환경변수 저장 (API키, DB 연결정보, 런타임 설정 등)
- 의존성 : package.json(npm, pnpm) , pom.xml 등에서 관리

→ package.json

```markdown
{
  "dependencies": {
    "react": "^18.2.0",
    "next": "13.0.0"
  },
  "devDependencies": {
    "eslint": "^8.10.0"
  }
}
```

→ .env.development / .env.production / .env.test

```markdown
# 클라이언트에서 사용할 변수 (CSR)
NEXT_PUBLIC_API_URL=http://localhost:8080

# 서버에서만 사용할 변수 (SSR)
API_SECRET_KEY=my-secret-key
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=securepassword
```

<**CSR과 SSR에서 `.env` 사용 방식 비교**>

| 구분 | CSR (클라이언트 렌더링) | SSR (서버 렌더링) |
| --- | --- | --- |
| **실행 위치** | 브라우저 | 서버 |
| **환경 변수 사용 방식** | `NEXT_PUBLIC_` 접두어 필요 | 일반 환경 변수 사용 가능 |
| **보안 수준** | 낮음 (환경 변수가 클라이언트에 노출됨) | 높음 (서버에서만 접근 가능) |
| **적용 예제** | `process.env.NEXT_PUBLIC_API_URL` | `process.env.API_URL` |
| **사용 사례** | API 호출, 클라이언트 측 기능 | DB 연결, 보안이 필요한 API 요청 |

 

## 3. 번들러, .env파일 빌드 시점

---

- Webpack, vite 같은 번들러는 `컴파일타임(빌드 시점)` 에 실행됨
    
    → 즉, 번들러가 살행될 때 모든 js,ts 코드가 하나의 번들로 합쳐지고 최적화됨.
    
    ex) Webpack 번들링 과정
    
    1. 컴파일 타임 : webpack이 코드 해석 및 번들링 → `.env` 읽고 DefinePlugin을 사용해서 변수를  JS코드에 주입함.
    2. 빌드 후 정적파일 (`bundle.js`) 생성함 : 이후 브라우저에서 js 실행(런타임) 

- `.env` 파일이 빌드되는 시점은 CSR, SSR, 백엔 환경에 따라 다름.
    - CSR에서는 컴파일 타임에 적용되고, SSR이랑 백엔드에서는 런타임에 적용된다.
    
    → 그래서 CSR에서는 빌드 후에 .env 변경해도 값이 반영되지 않음. (컴파일)
    
    → SSR : 요청이 올 때마다 서버에서 .env 값을 불러옴 (런타임) —> 배포 후에도 변경이 바로 적용됨
    
    → 백엔 : 항상 런타임에 .env를 불러옴. → 배포 후에도 .env 변경한 게 즉시 반영됨

</details>
